Nice — here’s a **single-file .NET C# (WinForms) application** that will run on **Windows XP and later**. It uses a **global hotkey** (Ctrl+Alt+T) to grab the currently selected text by simulating **Ctrl+C** (clipboard fallback) — this method is simple, reliable across many apps (browsers, PDF readers, Office, Notepad) and works on XP. After grabbing the text it calls **Google Cloud Translate v2** (you must supply your API key) and shows a small borderless popup near the mouse with the translation.

**Notes & limitations**

* This solution **does not inject** into other processes and works on Windows XP+.
* Clipboard method requires the target app to allow copying of selected text. Some protected/pdf viewers may block copying. If you want UI Automation / MSAA support in addition, we can add it later, but that significantly increases complexity (COM interop) and is fragile on XP.
* You must provide your **Google Cloud Translate API key** (v2). Add it to the `GOOGLE_API_KEY` constant. The project targets **.NET Framework 3.5** (XP-compatible).
* The app temporarily saves & restores the clipboard content so the user's clipboard is not lost.

---

### How to compile

1. Create a new **Windows Forms Application** in Visual Studio. Set target framework to **.NET Framework 3.5**.
2. Replace the autogenerated `Program.cs` and `Form1.cs` code with the single file code below (or create a single `Program.cs` containing all code).
3. Add a reference to `System.Runtime.Serialization` (for `DataContractJsonSerializer`).
4. Build & run.

---

### Full code (single file)

```csharp
// Program.cs
// Target: .NET Framework 3.5
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows.Forms;
using System.IO;
using System.Net;
using System.Text;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;

namespace HookTranslatorXP
{
    static class Program
    {
        // Put your Google Translate API v2 key here (required).
        // Get from Google Cloud Console -> APIs & Services -> Credentials.
        const string GOOGLE_API_KEY = "YOUR_GOOGLE_API_KEY_HERE";

        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm(GOOGLE_API_KEY));
        }
    }

    public class MainForm : Form
    {
        const int HOTKEY_ID = 9000;
        const uint MOD_ALT = 0x0001;
        const uint MOD_CONTROL = 0x0002;
        const int WM_HOTKEY = 0x0312;

        // Hotkey: Control + Alt + T
        const Keys HOTKEY = Keys.T;

        private string apiKey;
        private PopupWindow popup;
        private IntPtr msgWindowHandle;

        public MainForm(string googleApiKey)
        {
            apiKey = googleApiKey;
            InitForm();
            RegisterHotKey();

            popup = new PopupWindow();
            // Hide main window (app has no normal window as you requested)
            this.ShowInTaskbar = false;
            this.WindowState = FormWindowState.Minimized;
            this.Visible = false;
            this.FormBorderStyle = FormBorderStyle.FixedToolWindow;
            this.Opacity = 0; // hide
            this.Load += (s, e) => { this.Hide(); };
        }

        private void InitForm()
        {
            // invisible form - still receives messages for hotkey
            this.Text = "HookTranslator (hidden)";
            this.Size = new Size(1, 1);
        }

        protected override void WndProc(ref Message m)
        {
            if (m.Msg == WM_HOTKEY && (int)m.WParam == HOTKEY_ID)
            {
                // Hotkey pressed -> translate
                OnTranslateHotkey();
            }
            base.WndProc(ref m);
        }

        private void RegisterHotKey()
        {
            msgWindowHandle = this.Handle;
            bool ok = NativeMethods.RegisterHotKey(msgWindowHandle, HOTKEY_ID, MOD_CONTROL | MOD_ALT, (uint)HOTKEY);
            if (!ok)
            {
                MessageBox.Show("Failed to register hotkey Ctrl+Alt+T. Another app may be using it.", "HookTranslator", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            }
        }

        protected override void OnClosing(CancelEventArgs e)
        {
            NativeMethods.UnregisterHotKey(this.Handle, HOTKEY_ID);
            base.OnClosing(e);
        }

        private void OnTranslateHotkey()
        {
            // We run the copy/translate/show pipeline on a thread to avoid blocking UI
            ThreadPool.QueueUserWorkItem(_ =>
            {
                try
                {
                    string selected = GetSelectedTextByClipboardFallback();
                    if (string.IsNullOrWhiteSpace(selected))
                    {
                        // nothing captured
                        ShowPopup("No selectable text captured.");
                        return;
                    }

                    // Call Google Translate
                    string translated = TranslateViaGoogleV2(selected, "en", "auto", apiKey);
                    if (translated == null)
                        ShowPopup("Translate error.");
                    else
                        ShowPopup(translated);
                }
                catch (Exception ex)
                {
                    ShowPopup("Error: " + ex.Message);
                }
            });
        }

        private void ShowPopup(string text)
        {
            // Show popup near current mouse cursor
            Point p = Cursor.Position;
            popup.ShowTextNear(text, p);
        }

        private string GetSelectedTextByClipboardFallback()
        {
            // Steps:
            // 1) Backup current clipboard (if any).
            // 2) Simulate Ctrl+C (SendInput).
            // 3) Wait briefly and read CF_UNICODETEXT.
            // 4) Restore clipboard.

            IDataObject backup = null;
            try
            {
                if (Clipboard.ContainsData(DataFormats.Text) || Clipboard.ContainsData(DataFormats.UnicodeText) || Clipboard.GetDataObject() != null)
                {
                    backup = Clipboard.GetDataObject();
                }
            }
            catch
            {
                // Clipboard may be locked by other process, continue without backup.
                backup = null;
            }

            // Simulate Ctrl+C (key press)
            SendCtrlCToActiveWindow();

            // Wait and attempt to read clipboard (retry a few times)
            string result = null;
            for (int i = 0; i < 15; i++)
            {
                try
                {
                    if (Clipboard.ContainsText(TextDataFormat.UnicodeText))
                    {
                        result = Clipboard.GetText(TextDataFormat.UnicodeText);
                        if (!string.IsNullOrEmpty(result)) break;
                    }
                    else if (Clipboard.ContainsText(TextDataFormat.Text))
                    {
                        result = Clipboard.GetText(TextDataFormat.Text);
                        if (!string.IsNullOrEmpty(result)) break;
                    }
                }
                catch
                {
                    // Clipboard locked - retry
                }
                Thread.Sleep(40);
            }

            // Restore previous clipboard if we saved one
            if (backup != null)
            {
                try
                {
                    Clipboard.SetDataObject(backup, true);
                }
                catch
                {
                    // ignore restore failure
                }
            }

            return result ?? string.Empty;
        }

        private void SendCtrlCToActiveWindow()
        {
            // Use SendInput to simulate Ctrl+C (press and release)
            NativeMethods.INPUT[] inputs = new NativeMethods.INPUT[4];

            // Ctrl down
            inputs[0].type = NativeMethods.INPUT_KEYBOARD;
            inputs[0].ki.wVk = (short)NativeMethods.VK_CONTROL;
            inputs[0].ki.dwFlags = 0;

            // C down
            inputs[1].type = NativeMethods.INPUT_KEYBOARD;
            inputs[1].ki.wVk = (short)Keys.C;
            inputs[1].ki.dwFlags = 0;

            // C up
            inputs[2].type = NativeMethods.INPUT_KEYBOARD;
            inputs[2].ki.wVk = (short)Keys.C;
            inputs[2].ki.dwFlags = NativeMethods.KEYEVENTF_KEYUP;

            // Ctrl up
            inputs[3].type = NativeMethods.INPUT_KEYBOARD;
            inputs[3].ki.wVk = (short)NativeMethods.VK_CONTROL;
            inputs[3].ki.dwFlags = NativeMethods.KEYEVENTF_KEYUP;

            // Send
            NativeMethods.SendInput((uint)inputs.Length, inputs, Marshal.SizeOf(typeof(NativeMethods.INPUT)));
        }

        /// <summary>
        /// Calls Google Translate v2 API. Returns translated text or null on error.
        /// Minimal implementation using DataContractJsonSerializer.
        /// </summary>
        private string TranslateViaGoogleV2(string text, string targetLang, string sourceLang, string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) || apiKey.StartsWith("YOUR_"))
            {
                return "Google API key not set. Put your key in Program.cs.";
            }

            string url = "https://translation.googleapis.com/language/translate/v2?key=" + Uri.EscapeDataString(apiKey);

            // Build POST body as application/x-www-form-urlencoded (UTF-8)
            string body = "q=" + Uri.EscapeDataString(text)
                        + "&target=" + Uri.EscapeDataString(targetLang)
                        + "&format=" + Uri.EscapeDataString("text");
            if (!string.IsNullOrEmpty(sourceLang)) body += "&source=" + Uri.EscapeDataString(sourceLang);

            byte[] bodyBytes = Encoding.UTF8.GetBytes(body);

            try
            {
                HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);
                req.Method = "POST";
                req.ContentType = "application/x-www-form-urlencoded; charset=UTF-8";
                req.ContentLength = bodyBytes.Length;
                req.Timeout = 15000;

                using (Stream reqStream = req.GetRequestStream())
                {
                    reqStream.Write(bodyBytes, 0, bodyBytes.Length);
                }

                using (HttpWebResponse resp = (HttpWebResponse)req.GetResponse())
                {
                    using (Stream respStream = resp.GetResponseStream())
                    {
                        if (respStream == null) return null;
                        DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(GoogleTranslateResponse));
                        var data = (GoogleTranslateResponse)ser.ReadObject(respStream);
                        if (data != null && data.data != null && data.data.translations != null && data.data.translations.Length > 0)
                        {
                            // Return concatenated translations
                            StringBuilder sb = new StringBuilder();
                            foreach (var t in data.data.translations)
                            {
                                if (!string.IsNullOrEmpty(t.translatedText))
                                {
                                    sb.Append(t.translatedText);
                                    sb.Append("\n");
                                }
                            }
                            return sb.ToString().Trim();
                        }
                    }
                }
            }
            catch (WebException wex)
            {
                try
                {
                    using (var er = wex.Response?.GetResponseStream())
                    {
                        if (er != null)
                        {
                            using (var sr = new StreamReader(er))
                            {
                                string err = sr.ReadToEnd();
                                return "Translate error: " + err;
                            }
                        }
                    }
                }
                catch { }
                return "Translate WebException: " + wex.Message;
            }
            catch (Exception ex)
            {
                return "Translate Exception: " + ex.Message;
            }

            return null;
        }

        [DataContract]
        class GoogleTranslateResponse
        {
            [DataMember]
            public GoogleData data { get; set; }
        }
        [DataContract]
        class GoogleData
        {
            [DataMember]
            public GoogleTranslation[] translations { get; set; }
        }
        [DataContract]
        class GoogleTranslation
        {
            [DataMember]
            public string translatedText { get; set; }
            [DataMember]
            public string detectedSourceLanguage { get; set; }
        }
    }

    /// <summary>
    /// A minimalist popup window that shows translated text near a given screen point.
    /// Auto-hides after a few seconds. Topmost, borderless.
    /// </summary>
    public class PopupWindow : Form
    {
        Label lbl;
        System.Windows.Forms.Timer hideTimer;

        public PopupWindow()
        {
            FormBorderStyle = FormBorderStyle.None;
            ShowInTaskbar = false;
            TopMost = true;
            StartPosition = FormStartPosition.Manual;
            BackColor = Color.FromArgb(30, 30, 30);
            ForeColor = Color.White;
            Padding = new Padding(8);
            DoubleBuffered = true;
            lbl = new Label();
            lbl.AutoSize = false;
            lbl.TextAlign = ContentAlignment.MiddleLeft;
            lbl.MaximumSize = new Size(600, 400);
            lbl.Font = new Font("Segoe UI", 10);
            lbl.BackColor = Color.Transparent;
            lbl.ForeColor = Color.White;
            Controls.Add(lbl);
            this.Deactivate += (s, e) => { /* don't hide on deactivate */ };

            hideTimer = new System.Windows.Forms.Timer();
            hideTimer.Interval = 6000; // 6 seconds default
            hideTimer.Tick += (s, e) => { hideTimer.Stop(); this.Hide(); };
            // allow click to copy to clipboard
            this.Click += (s, e) => { TryCopyLabelTextToClipboard(); };
            lbl.Click += (s, e) => { TryCopyLabelTextToClipboard(); };

            // Rounded corners on modern systems are not necessary; keep simple to support XP.
        }

        private void TryCopyLabelTextToClipboard()
        {
            try
            {
                Clipboard.SetText(lbl.Text);
                // Visual feedback: change background briefly
                Color old = BackColor;
                BackColor = Color.FromArgb(20, 120, 20);
                var t = new System.Windows.Forms.Timer();
                t.Interval = 300;
                t.Tick += (s, e) => { BackColor = old; t.Stop(); };
                t.Start();
            }
            catch { }
        }

        public void ShowTextNear(string text, Point screenPoint)
        {
            if (string.IsNullOrEmpty(text)) text = "(empty)";

            // Shorten overly long text for popup preview
            string preview = text;
            if (preview.Length > 1000) preview = preview.Substring(0, 1000) + "...";

            // Ensure UI actions on UI thread
            if (this.InvokeRequired)
            {
                this.BeginInvoke((MethodInvoker)(() => ShowTextNear(text, screenPoint)));
                return;
            }

            lbl.Text = preview;
            // Resize form to label
            lbl.Size = TextRenderer.MeasureText(preview, lbl.Font, new Size(lbl.MaximumSize.Width, lbl.MaximumSize.Height), TextFormatFlags.WordBreak);
            this.ClientSize = new Size(lbl.Width + Padding.Left + Padding.Right, lbl.Height + Padding.Top + Padding.Bottom);

            // Position: slightly above or below the cursor depending on screen bounds
            Rectangle screen = Screen.FromPoint(screenPoint).WorkingArea;
            int x = screenPoint.X + 12;
            int y = screenPoint.Y + 18;
            if (x + this.Width > screen.Right) x = screen.Right - this.Width - 8;
            if (y + this.Height > screen.Bottom) y = screenPoint.Y - this.Height - 8;
            if (y < screen.Top) y = screen.Top + 8;
            this.Location = new Point(Math.Max(screen.Left + 8, x), Math.Max(screen.Top + 8, y));

            this.Opacity = 0.95;
            this.Show();
            this.BringToFront();

            hideTimer.Stop();
            hideTimer.Start();
        }
    }

    static class NativeMethods
    {
        public const int INPUT_KEYBOARD = 1;
        public const uint KEYEVENTF_KEYUP = 0x0002;

        public const int VK_CONTROL = 0x11;

        [StructLayout(LayoutKind.Sequential)]
        public struct INPUT
        {
            public int type;
            public INPUTUNION ki;
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct INPUTUNION
        {
            [FieldOffset(0)]
            public KEYBDINPUT ki;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KEYBDINPUT
        {
            public short wVk;
            public short wScan;
            public uint dwFlags;
            public uint time;
            public IntPtr dwExtraInfo;
        }

        [DllImport("user32.dll", SetLastError = true)]
        public static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);

        // Hotkey API
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool RegisterHotKey(IntPtr hWnd, int id, uint fsModifiers, uint vk);

        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool UnregisterHotKey(IntPtr hWnd, int id);

        public const int WM_CLIPBOARDUPDATE = 0x031D;

        public const uint KEYEVENTF_KEYDOWN = 0x0000;
    }
}
```

---

### Quick usage

* Run the app. It runs hidden.
* Select text in any app (browser, PDF viewer, Word, Notepad).
* Press **Ctrl+Alt+T**. The app will simulate `Ctrl+C`, read clipboard, call Google Translate (to English by default), and show a small popup near your mouse with the translation.
* Click the popup to copy the translation to clipboard.

---

If you want, next I can:

* Add **UI Automation + MSAA** fallbacks so the tool tries direct read first (useful for apps that block clipboard) — this is doable but requires COM interop and careful testing across XP/Win7+.
* Add a settings UI (choose target language, change hotkey, allow auto-trigger on selection change, whitelist/blacklist apps, caching).
* Make the popup richer (inline pronunciation, copy/share buttons) and DPI-aware.

Want me to add MSAA/UIA fallback now (more code & testing) or is the clipboard-based MVP good for you?
